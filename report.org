#+TITLE: Architectural Reconstruction
#+OPTIONS: toc:nil
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \chead{Architectural Reconstruction}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \rfoot{Casper Weiss Bang}
#+LATEX_HEADER: \lfoot{cawb@itu.dk}
#+LATEX_HEADER: \cfoot{\thepage\ of \pageref{LastPage}}
* Introduction
This paper will explore the architecture of the flask[fn:flask] web framework.
Flask is a lightweight web application framework, based on WSGI[fn:wsgi]. as
explained on their github repository. The code analysis will be done by
constructing two small scripts that extract relevant data from the target
framework. These two scripts will be built through this paper in an evolutionary
development process, where the paper will highlight the intermediate steps.

The reason for this evolutionary practice is two fold, both to enlighten the
reader on the development process and how python can be utilizing for this
intent, but also to show the architectural process with and the aspects revealed
about the flask framework. The code analysis will be done in python utilizing
reflection[fn:reflection], and combine both dynamic and static code analysis, in
this way. This paper is, however, just one way of utilizing reflection in
python, and leaves it out of scope to evaluate on the type of reflection
utilized, but will briefly mention other types as a future topic of study.
Finally it will conclude on the findings of the flask framework, the value of
the autogenerated graphs, as well as utilizing reflection to do architectural
reconstruction.
* Problem Elicitation
An architectural reconstruction process is initialized by a problem from faced
by stakeholders. This is naturally difficult, as I operate as an external actor
without prior knowledge of the system or connection to any known stakeholders.
For these reason, the stakeholder and problem analysis part has been left out,
and I instead create an imagined problem.

Multiple opensource frameworks have a great documentation for usage, but poor
documentation for maintainers. Architecture and similar aspects of the
development process is often done by accident or at the very least not done
explicitly. This makes it difficult for new maintainers to join large projects,
as they often have large code bases, which can be difficult to get a fulfilling
overview of.

However, maintaining a great architectural model of a system can be expensive
and take time, especially in an often underfunded opensource project. Therefore
automation is crucial for such a model to continuously be up-to-date with the
state of the codebase.

Based on these considerations the following two problems has been decided upon.

#+BEGIN_QUOTE
As a *potential future maintainer*, I would like to get an overview of the
system, so I understand the system to a degree that makes it possible to solve
issues.

As an *active maintainer*, I want any architectural document to be fully
automated, so I don't need to update it when changing the source code, which I
might forget or discourage me from developing the system.
#+END_QUOTE

** Project choice
 After quickly brainstorming for various interesting frameworks, preferably
 build around python as that is, to date, my favorite programming language, I
 decided upon using Flask as my target framework. Flask is, in my opinion, an
 interesting choice for a few different reasons:
 - Lacks documentation :: As is often the case in projects of this type,Flask
   has a great documentation for how to usage but are less documented from a
   contributors point of view. Flask does have a great level of inline comments,
   making it easier to understand each component of the system, and these
   comments are transpiled into an online documentation, however understanding
   the context of each element is difficult, and requires a throughout reading
   of the source code at the current point in time.
 - Broad adoption :: It is used by a lot of different developers across the
   world. It has fifty thousand stars on github[fn:repo], which generally
   speaking only reflects a small subset of active users, as I, for instance,
   have used flask multiple times but haven't given it a star on github. Having
   a large user group makes the project more interesting and makes the results
   both interesting and relevant. Also for the simple reason that it is
   interesting to learn the inner workings on a broadly adopted framework.
 - Size :: Flask is, compared to other python web frameworks, relatively small.
   This makesit easier to draw readable diagrams, without being cumbered by the
   inherit size of the framework. The framework is, however, still of a size
   that it is difficult to fully grasp simply by looking at the source code,
   making it ideal for study, as it gives reasonable challenges.
 - Person interest :: I've used flask a multitude of times and would love to
   learn how it works. It is also a great example as a sort of proof-of-concept
   of recovering the architecture of an open-source project, which might be an
   interesting study to delve into at a later point.

Based on these considerations I chose the Flask framework.
* Selecting the views
As previously mentioned this process will be artificial in nature, and primarily
focused on my assumptions of the needs of a maintainer. The choices are based on
on my prior experiences with exploring and familiarizing myself with any new
framework or technology. The choices are based on the 3+1 architectural
model[fn:3plus1], but also inspired by the 4+1 model[fn:4plus1], as these are
similar in nature. The naming will be used I have chosen to produce the
following views, based on such considerations:
- Component Diagram :: This view will map each module of the framework, and how
  these are interdependent. It shall include direct external dependencies, so
  any module that any part of the =Flask= framework explicitly includes, however
  any second-degree dependency will be ignored, to keep the view simpler in
  nature. This will provide an abstract overview of the system, and should
  detail how various parts of the system work together, to understand the areas
  of responsibility as well as the overall structure and dependencies of these
  modules.
- Class Diagram :: The development view is essentially abstract in nature, and
  lack the concrete classes and makes it difficult to actually know where
  various classes lie. A logical view provides a closer look at the classes, and
  how these relate to eachother, be in inheritance or association. The current
  API document of flask[fn:api_docs], contains a list of the most important
  classes, but it is difficult to fully grasp how these fit together, nor get a
  quick overview of the relations without jumping back and forth in the
  documentation.

These two diagrams cover the /Development View/ and the /Logical View/ of the
4+1[fn:4plus1] model, and are both covered in the /Module View/ of the 3+1
architectural model[fn:3plus1].

This report will elude any target views, as the goal of the reconstruction will
be the source views, which makes this report diverge from the Symphony
Model[fn:symphony], that is normally used in architectural recovery. The
reasoning largely stems from the fact that the model does not fully fit the
current usecase fully.

** The tools and work process
The following parts of the paper, will show various code snippets and graphs.

All code snippets will be written in Python3.8, however should work on any
Python version greater than Python3.6. The paper will first illustrate the snippet and below it will show the output of
said snippet. When the python code is used to generate graphs, it will elude the
textual output of the snippet, and simply show the visual representation of the
graph.

The graphs will be generatted using graphviz[fn:graphviz], as
it can easily be generated and then compiled in a variety of different styles,
and, on top of this, it makes it easy to modify graphs manually, as well as
separate the information extraction task from the rendering task. This means,
however, that the python snippet will write graphviz code as output for these
tasks - the print statements used for this should simply be ignored by the
novice, reader, and is always wrapped in a standalone function explaining the
contextual meaning of the generated graphviz code.

To do this analysis, the full capabilities of
the Python interpreter will be utilized, by analyzing code and structure with reflection[fn:reflection] at
runtime. This is partially as a technical challenge, but also to explore the
capabilities of code analysis done via reflection.

The sourcecode of the various objects will be analyzed, however this will also
be done via reflection, making the solution a mixture of dynamic and static code analysis.
The upside of this, is that there is a certainty that the findings are
reflecting the actual running piece of software at runtime.

The paper is written in org-mode in Emacs, and the sourcecode can be found on
github[fn:report_source]. Any reader that utilizes the Emacs editor can browse
the sourcefiles, and can more easily play around with the snippets and
intermediate results, however this is only for advanced users. The repository
also contains the final snippets as stand alone scripts in a slightly modified
version for readability, and can be inspected for any interested novice python
user.

* Data Gathering
Before delving into the generation of the views, we will start by gathering
information about the Flask package.
Initially we install the package from pip[fn:pip], whereafter we simply import
the module, and check the docstring, the string containing the explanation of
the package. Additionally, the version number is included, to make it easier
for the reader to reason about any deviation to the ones shown in the report.

#+BEGIN_SRC python :results output :exports both
import flask
print(flask.__doc__)
print("version:", flask.__version__)
#+END_SRC

#+RESULTS:
#+begin_example

    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: 2010 Pallets
    :license: BSD-3-Clause

version: 1.1.2
#+end_example

This lets us know that the framework should essentially be small in size, which
is nice for the sake of this analysis, but it also mentions a primary dependency
on the /Werkzeug/ package. To figure out exactly what Werkzeug does, we can
simply import that and read their docstring. This is possible because the
installation of flask also installs all dependencies, which we then have access
to as well.
#+BEGIN_SRC python :results output :exports both
import werkzeug
print(werkzeug.__doc__)
#+END_SRC

#+RESULTS:
#+begin_example

werkzeug
~~~~~~~~

Werkzeug is the Swiss Army knife of Python web development.

It provides useful classes and functions for any WSGI application to
make the life of a Python web developer much easier. All of the provided
classes are independent from each other so you can mix it with any other
library.

:copyright: 2007 Pallets
:license: BSD-3-Clause

#+end_example

This is less relevant for Flask, however it is interesting to know. We can hope
to see that flask outsources some things, and that the sourcecode and structure
is simpler. It is also furthers to understand the context of Flask.

For completeness, before looking into the gathering more information, it is
crucial to understand how to use, from an end-user perspective, the framework.
The following snippet is taken from their documentation.[fn:minimal_app]
#+BEGIN_SRC python :exports code
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'
#+END_SRC

Next, lets look at all objects and classes, that the flask framework exposes,
i.e all modules, functions, types and constants that can be imported by
importing the flask framework. We will generate a helper function for fetching
these, utilizing the =dir= function, which returns a list of attributes of a
given object, here a unspecified module.[fn:dirfunc]

#+BEGIN_SRC python :exports code :session main
from types import ModuleType
from typing import List
def get_objs(module: ModuleType) -> List[object]:
  return [
    (name,getattr(module,name))
    for name in dir(module)
  ]
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 11, in <module>
:   File "<string>", line 3, in <module>
: NameError: name 'ModeuleType' is not defined


Any module and instance
We will ignore all private identifiers, which in python is
denoted by a =_= prefix. We also want to know the type of each attribute, to
understand what it is. The output list is shortened for the sake of readability,
however the reader is encouraged to check all output if interested. We could
also check the docstring, if relevant, however this is left for the user, if
interested in specific attributes.
#+BEGIN_SRC python :results output :exports both :session main
import flask

def print_list(elements):
  # cast to list, so it works for generators and sets
  elements = list(elements)
  formatted ='\n- ' +('\n- '.join(
    str(el) for el in elements[:5]
  ))
  print(
    f"{len(elements)} elements. "
    f"Among others:{formatted}"
  )

print_list(
  f"{label} ({type(obj)})"
  for label, obj in get_objs(flask)
  if not label.startswith("_")
)

#+END_SRC

#+RESULTS:
: 55 elements. Among others:
: - Blueprint (<class 'type'>)
: - Config (<class 'type'>)
: - Flask (<class 'type'>)
: - Markup (<class 'type'>)
: - Request (<class 'type'>)

We can then see that flask exposes a large set of different types, which are classes, and upon
expecting the full list also functions, submodules,
functions and classes.
We can see some interesting types, forexample the =Request= class, which
presumably is of big interest in a web framework, but also the =Flask= class,
which is a crucial class when using the framework. It however, also shows that
the structure is tree like, and not flat. This is obvious based on some of the
submodules exposed, i.e =flask.testing=.

We can also, alternatively, look at all the modules loaded into the interpreter
when loading in the =flask= module.
We do this by first getting the list of all modules prior to import flask, and
then taking the difference of that with the modules loaded after importing flask.
#+BEGIN_SRC python :results output :exports both
import sys
initial_modules = set(sys.modules)
import flask
diff_modules = set(sys.modules) - initial_modules
print(f"{len(initial_modules):>3} initial modules")
print(f"{len(diff_modules):>3} imported modules")
print(f"{len(sys.modules):>3} loaded modules")

#+END_SRC

#+RESULTS:
:  57 initial modules
: 205 imported modules
: 262 loaded modules

This points in the direction of the complexity of the system, as it shows all
the external as well as internal modules. It does not say anything about the
size of each of those modules, however by inspecting the sourcecode, we could
generate this. For this we generate a =LOC= function that checks the
total number of lines of code for a given module. We utilize the
=inspect.getsource= function for this, however this only works on non-builtin
objects. The LOC also includes comments and blank lines, and shouldn't be taken
as a clear metric of the system, however it does give a ballpark estimate of the
size of the project
#+BEGIN_SRC python :results output :exports both
import inspect
import sys
initial_modules = set(sys.modules)
import flask
diff_modules = sorted(set(sys.modules) - initial_modules)
def LOC(module):
  try:
    return len(inspect.getsource(module).split("\n"))
  except (OSError,TypeError):
    return 0
def sum_loc(iffunc = None):
  return sum(
    LOC(sys.modules[module])
    for module in diff_modules
    if not iffunc or iffunc(module)
  )
imported_lines = sum_loc()
flask_lines = sum_loc(
  lambda module: module.startswith("flask")
)
werkzeug_lines = sum_loc(
  lambda module: module.startswith("werkzeug")
)
pct_flask_size = flask_lines/imported_lines*100
pct_werkzeug_size = werkzeug_lines/imported_lines*100

print(f"{imported_lines:>5} imported lines of code")
print(f"{flask_lines:>5} lines of code in flask")
print(f"Flask covers {pct_flask_size:.2f}% of total lines")
print(f"Werkzeug covers {pct_werkzeug_size:.2f}% of total lines")

#+END_SRC

#+RESULTS:
: 94841 imported lines of code
:  7728 lines of code in flask
: Flask covers 8.15% of total lines
: Werkzeug covers 18.10% of total lines

This shows that the flask application is rather small compared to the total
dependencies, and does point towards the statement made in their docs, that it
is light weight, and that it is heavily dependent on external dependencies,
especially the Werkzeug module.

* Graph creation
We have gained an initial understanding of what Flask is, how it is used, and
what submodules and types are being exposed. From here we can delve into the
generation of the graphs, and look at a more structural graphical view of the
system.

** Component Diagram
To get a graph we need to know what is a direct dependency and what is an
indirect dependency. To do this we will, once again, do static code analysis
with the help of the =inspect= module. Here we can fetch any line starting with
=import=. To do this we create a =get_imports= function.

#+BEGIN_SRC python :results output :exports both :session main
import inspect
import re
def get_imports(module):
  regex = r"^(import|from)\s(\.?\w*)"
  source = inspect.getsource(module)
  return sorted(set(
    # get the `(\.?\w*)` pattern in the match
    match[1]
    for match in re.findall(regex, source, re.MULTILINE)
  ))

import flask
print_list(get_imports(flask))
#+END_SRC

#+RESULTS:
: 13 elements. Among others:
: - .
: - ._compat
: - .app
: - .blueprints
: - .config
This gives us a list of the direct imports, which is a lot more interesting, and
can be used to generate a graph. We have to understand the imports however -
anything prefixed with a dot, i.e =.app= is a relative import, so the full
qualifier would be =flask.app=, because we are currently in the flask application.
we can convert these to absolute name, and ignore the =.= import.

#+BEGIN_SRC python :results output :exports both :session main
def get_abs_imports(
    module:ModuleType,
    base_name:str
) -> List[str]:
  return [
    (
      base_name + imp
      if imp.startswith(".")
      else imp
    )
    for imp in get_imports(module)
    if imp not in ["","."]
  ]

print_list(get_abs_imports(flask,"flask"))
#+END_SRC

#+RESULTS:
: 12 elements. Among others:
: - flask._compat
: - flask.app
: - flask.blueprints
: - flask.config
: - flask.ctx

We can then use this list to import each module and then look at the source for
each of these, and with that recursively check all dependencies. We then
generate a graph based on this recursive process. The color of external
dependencies are set to dark gray to easily differentiate between internal and
external dependencies. The following snippet shows all the helper functions we
will create for recursively mapping these dependencies.

#+BEGIN_SRC python :results output :exports code :session main
import importlib
# to make sure we don't get an infinite loop
visited = []

def print_dependency(start:ModuleType, end:ModuleType, color:str=""):
     color = f'fontcolor="{color}" color="{color}"' if color else ""
     print(f'{hash(start)} -> {hash(end)} [{color}]')
def print_label(module:ModuleType, color:str=""):
     color = f'fontcolor="{color}" color="{color}"' if color else ""
     print(f'{hash(module)} [label="{module.__name__}" {color}]\n')

def recursive_print_imports(
    module:ModuleType,
    base_name:str,
    only_internal: bool = False):
   if module in visited:
     return
   visited.append(module)
   print_label(module)
   for import_name in get_abs_imports(module, base_name):
     internal = import_name.startswith(base_name)
     if not internal and only_internal:
       continue
     import_module = importlib.import_module(import_name)
     color = "darkgrey" if not internal else ""
     print_dependency(module, import_module, color)
     print_label(import_module, color)
     if internal:
       recursive_print_imports(
         import_module,
         base_name,
         only_internal
       )

#+END_SRC

These helper functions can then be utilized to render the component diagram.
#+NAME: dependency-internal
#+BEGIN_SRC python :results output :exports code :session main
visited = []
flask_modules = [
  module
  for label, module in sys.modules.items()
  if label.startswith("flask")
]
for module in flask_modules:
  recursive_print_imports(module, "flask", only_internal=True)
#+END_SRC


#+BEGIN_SRC dot :file images/dependency-internal.png :var input=dependency-internal :exports results
digraph {
  node [
    fontsize = 8
  ]
 $input
}
#+END_SRC


These images can also be seen in the sourcefiles of the report[fn:report_source].
The structure seems clear and well though out. You can see a clear hierarchy,
and a modular construction of the system. This is naturally a good sign. We also
see that there is no circular dependencies, and, based on the titles of the
modules, seems to have a clear separation of responsibilities.
#+NAME: dependency-external
#+BEGIN_SRC python :results output :exports code :session main
visited = []
flask_modules = [
  module
  for label, module in sys.modules.items()
  if label.startswith("flask")
]
for module in flask_modules:
  recursive_print_imports(module, "flask", only_internal=False)
#+END_SRC


#+BEGIN_SRC dot :file images/dependency-external.png :var input=dependency-external :exports results
digraph {
  node [
    fontsize = 8
  ]
 $input
}
#+END_SRC

#+RESULTS:
[[file:images/dependency-external.png]]

Here we can see various dependencies, of different types and importance. At the
lowest level, with the largest count of on incoming edges, we see the =Werkzeug=
module. This highlights the fact that there is a closely knitted relationship
to =Werkzeug=.  The base module, =flask=, depends only on very few external
dependencies, and with the external modules included, it is clear to see that
functionality is wrapped through the sub modules. We can, however, also see that
=flask.json.tag= seems to have no usage. This can be because references are
implicit, due to the dynamic nature of the language. Upon inspecting the docstring
this seems to be the case. I have manually picked the line of interest in the
following snippet, for briefness.
#+BEGIN_SRC python :results output :exports both :session main
print(flask.json.tag.__doc__.split("\n")[4])
#+END_SRC

#+RESULTS:
: A compact representation for lossless serialization of non-standard JSON types.

The observed structure is clear and hierarchical, and seems to be of high
quality.
** Class diagram
The class diagram should contain both association, but also inheritance, and
therefore both types of relations needs to be understood. This section will
first show how these relations can be found, and afterwards generate a graph
based on these connections. Initially we will focus on the =flask.Flask= class,
as it is the core of the Flask framework class.
*** Inheritance
To check for inheritance, we can utilize the =__base__= function that is exposed
on classes. The following snippet will extract a list of all superclasses of the
=flask.Flask=, and then display the documentation for each.
#+BEGIN_SRC python :results output :exports both
import flask
superclasses = [
  f"{dep.__name__}:\n  Docs: {dep.__doc__}"
  for dep in flask.Flask.__bases__
 ]
print(*superclasses, sep="\n")
#+END_SRC

#+RESULTS:
: _PackageBoundObject:
:   Docs: None

We learned little other than it depends on an undocumented class, =_PackageBoundObject=.

Instead we can try to look at what different functions, classes and instances
the =Flask= class references.


*** Check for references to classes in sourcecode
The dynamic nature of Python makes references a difficult thing to gather.
Python did include the =typing= library in Python3.5, which makes type
annotation easier, and this is used for the snippet of this paper, however few
frameworks utilize it. For this reason we can only be certain of any explicit
dependencies. If, for instance, a function depends on a certain input type, it
can be impossible to know the type as this is essentially implicit.
Worth noting is that due to the dynamically typing of python, it can be
difficult to get a list of dependencies and references inside the function,
however we can see any direct usage, however any expected input types of various
functions aren't possible to deduce without any typing or usage examples.

We, therefore, limit the scope of the class diagram to any explicit dependency.

Utilizing the =inspect= module and the list of available classes, we can check
if the source contains any reference to any of the available classes, which
illuminates a dependency. The class diagram will be limited to dependencies on
other classes, so any dependency on specific functions are hidden. These could
easily be integrated as well, but are hidden for the sake of readability.

To do this, we initially need some helper functions, to remove comments and
strings. References to an object in comments might yield interesting results as
well, and illuminate references in docstrings, however for the time being, these
are ignored as to make sure that only actual dependencies are accounted for.

Here we print all references the sourcecode of =flask.Flask= has to other classes.
#+BEGIN_SRC python :results output :exports both :session main
import re

def remove_comments_and_strings(code: str) -> str:
    code = re.sub(re.compile("#.*?\n" ) ,"" ,code)
    code = re.sub(re.compile("\"\"\".*?\"\"\"", re.DOTALL) ,"" ,code)
    code = re.sub(re.compile("\".*?\"" ) ,"" ,code)
    code = re.sub(re.compile("\'.*?\'" ) ,"" ,code)
    code = re.sub(re.compile("\`.*?\`" ) ,"" ,code)
    return code

def get_clean_source(obj: object) -> str:
  return remove_comments_and_strings(inspect.getsource(obj))

def get_references_for_module_obj(source: str, module_name: str, obj_name: str):
  output = []
  matches = set(
    match[0]
    for match in
    re.findall(f"[^.\w\d]({obj_name}(\.[\w\d_]+)+)", source, re.MULTILINE)
  )
  for match in matches:
    try:
      while not isinstance(eval(module_name + "." + match), type):
        match = ".".join(match.split(".")[:-1])
    except (AttributeError, SyntaxError):
      continue
    output.append(eval(module_name + "." + match))
  return output

def get_references(klass: type) -> List[type]:
  source = get_clean_source(klass)
  module_name =klass.__module__
  module = eval(module_name)
  output = []
  for obj_name, obj in get_objs(module):
    if obj is klass:
      continue
    if isinstance(obj, ModuleType):
      output += get_references_for_module_obj(source, module_name, obj_name)
    elif (
      isinstance(obj, type)
      and re.findall(f"[^.\w\d]{obj_name}", source, re.MULTILINE)
    ):
      output.append(obj)
  return set(output)
print_list(
  ref.__name__
  for ref in get_references(flask.Flask)
)
#+END_SRC

#+RESULTS:
: 30 elements. Among others:
: - BadRequestKeyError
: - RoutingException
: - Headers
: - Map
: - AppContext

We can then see a wide variety of different dependencies, some which are more
interesting than other. Of the first 5, we can see multiple exceptions, and
further down the list we can see the =Request= class, which is of higher
interest, as it presumably contains information about web requests in context of
the web framework.
*** Generating the graph
Based on these two prior snippets, we can recursively find references and then
generate yet another graph.

We ignore the methods and attributes of the classes and only focus on the
relations between them. The current documentation is a great source for the
content and intent of each class. This is partially to keep the graph simple,
but also because of the difficulty of dynamically finding the functions of
highest importance.

The script checks all internal classes and any external direct dependencies of
these. Grey arrows are representing association, and black arrows are
representing inheritance. Arrows show the direction of the dependency.

#+NAME: class-diagram
#+BEGIN_SRC python :results output :exports code :session main
import flask
import flask.testing

def print_module(dep):
  print(
    f'subgraph cluster_{abs(hash(dep.__module__))}{{\n'
    f'{hash(dep)};\n'
    f'label=\"{dep.__module__}\"\n}}'
  )

visited = []
def map_dependencies(klass: type):
  if klass in visited or not klass.__module__.startswith("flask"):
    return
  print_module(klass)
  print_label(klass)
  visited.append(klass)
  for ref in get_references(klass):
    print_dependency(
      klass,
      ref,
      "darkgrey" if not ref in klass.__bases__ else ""
    )
    print_module(ref)
    print_label(ref)
    map_dependencies(ref)
flask_klasses =  set(
  obj
  for module in flask_modules
  for _, obj in get_objs(module)
  if isinstance(obj, type)
  and obj.__module__.startswith("flask.")
)
for obj in flask_klasses:
  map_dependencies(obj)
#+END_SRC


#+BEGIN_SRC dot :file images/class-diagram.png :var input=class-diagram :exports results
digraph {
    fontsize = 8
    rankdir = "BT"
    node [
         fontsize = 8
         shape = "record"
    ]
    $input
}
#+END_SRC


This diagram shows an even clearer structure, than the component diagram
provided. The image is rather wide, which is a fault of the graph rendering
engine rather than the system. There is a hierarchical structure to the system,
and it is somewhat easy to get an overview of the various classes. We can
clearly see that the =flask.testing= module is in no way dependent on the rest
of the framework or vice versa, which details a loose coupling between these,
presumably making it easier to maintain tests even with a evolving framework. We
can see =TaggedJSONSerializer=, which seemingly not used anywhere, however I
presume this to be the fault of the dynamic nature of the programming language,
however it is difficult to be certain.

One worry, however, is that the =flask.Flask= class seems to be a god-class of
sorts, a class with too many different roles, as it is interconnected with every
other class. Utilizing our =LOC= function, we can check if the size of the class
relatively easy. The LOC function is slightly modified, making it ignores any
comment.
#+BEGIN_SRC python :results output :exports both :session main

def LOC(module):
  try:
    return len(get_clean_source(module).split("\n"))
  except (OSError,TypeError):
    return 0

klass_lines = LOC(flask.Flask)
total_lines = sum(
  LOC(module)
  for module in flask_modules
)
pct = klass_lines/total_lines * 100
print(f"{klass_lines:>4} lines in the Flask class")
print(f"{total_lines:>4} lines in total")
print(f"flask.Flask {pct:.2f}% of the framework")
#+END_SRC

#+RESULTS:
: 1038 lines in the Flask class
: 4698 lines in total
: flask.Flask 22.09% of the framework

This is worrying, as this means makes the class difficult to maintain. It should
almost certainly be broken into several files, classes and responsibilities.
There are no clear guidelines from the python style guide[fn:pep8] about ideal
file sizes, however personally I would argue that any file larger than 200-300 lines
should be split into several files, however this is a singular file.
We can also easily see if this is a general trend or style of the system.
#+BEGIN_SRC python :results output :exports both :session main

print_list(sorted(
  (
    (klass, LOC(klass), f"{LOC(klass)/total_lines*100:.2f}%")
    for klass in flask_klasses
  ),
  key=lambda el: el[1], reverse=True
))

#+END_SRC

#+RESULTS:
: 45 elements. Among others:
: - (<class 'flask.app.Flask'>, 2366, '29.53%')
: - (<class 'flask.blueprints.Blueprint'>, 481, '6.00%')
: - (<class 'flask.config.Config'>, 230, '2.87%')
: - (<class 'flask.ctx.RequestContext'>, 222, '2.77%')
: - (<class 'flask.sessions.SessionInterface'>, 191, '2.38%')

This is clearly not the case, and the =Flask= class is an outlier. This makes
sense in that the =Flask= class is crucial in system, however it is still
problematic and should probably be addressed. Large files or classes makes code
difficult to read and therefore harder to maintain, it can also be a sign of a
class having too many different responsibilities.
Without delving into the code I cannot with certainty say that this has to be
addressed, but it is definitely a red flag, without proper reasoning for this
choice.
* Evaluating the view
Without proper acceptance tests it is difficult to qualitatively evaluate the
recovered architecture. However I, to mimic a maintenance task, looked
at an issue on their github repository; /Unable to extend FlaskClient with
follow_redirects/[fn:chosen_issue]. I did not solve the issue due to limited
time, however I and was able to get an overview of the files at fault.

It did show some shortcomings of the current format. Normally an architectural
document is currated somewhat and via human interaction is pruned to only
contain the relevant classes. Finding something in the current solution is
rather difficult for this reason. The class diagram, for instance, is rather
large and it took me some time to find the classes in question, however after
finding it, it did help me understand the context of the problem. I looked at
the =open= method of the =FlaskClient=, and was rather quickly able to
understand the context simply based on the diagrams previously seen. The class
diagram could have benefitted with any short explanation of the purpose of the
class as well as the exposed methods.

When doing this exercise I did consider whether this reflection-based code
analysis was a good choice. I find multiple upsides to this analysis method,
mainly related to the fact that python is an intepreted language, meaning that
static code analysis can lead to various errors, because it can be difficult to
easily deduce the type of something.

An example of the problems related to static code analysis was revealed as I
browsed the =flask= source-code on Github[fn:repo]. Github can show you a list
of references, when looking at a given identifier, however the below image shows
an error of this function. I am inspecting =werkzeug.test.EnvironBuilder=,
however the 7 references are actually references to
=flask.testing.EnvironBuilder=. The errors is due to the class having the same
name, so the static analysis cannot tell them apart.

[[./images/github_static_analysis.png][Github Static Code Analysis fails]]

The example is just a random bug, however it still shows an interesting aspect
of reflection. Sometimes, especially regarding dynamically typed languages,
reflection gives a more truthful answer than static code analysis, as you can
check exactly what a given variable actually is, rather than assume based on the
identifier name.


* Conclusion
The two graphs show the structure of flask as well as how it dependens on it's
various dependencies.

We can see a close knitted relationship with =werkzeug=, which is expected based
on the description of the =Flask= framework. We can see that the system seems to
have a clear structure, and that only a singular cyclic dependencies exists. We
can also see that the sourcecode is relatively small and simple, based on the
class count. We, however, brought to light the relatively large size of the
=flask.app.Flask= class, which composed of many thousands of lines. This is
definitely a codesmell, and should ideally be addressed.

The evaluation showed promising values gained from the relatively simple graphs
generated, and points towards the value of automatically generated architecture,
both in the low maintainability compared to manual documents, which is important
in an open source context, but also in the value a maintainer can gain from
inspecting these. One could hope that a greater level on documentation would
encourage more people to take part in the open source community.

The recovery methodology was interesting to work with, but also showed a new way
to generate architectural documents, combining the aspects from both dynamic and
static code analysis.

* Future Work
** Interactive tool
It would definitely help if the graph were more interactive. Looking through the
diagram was difficult, and could use a search function of sorts. Additionally it
would be nice to be able to connect the graph to the documentation. A feature
could be the ability to click on a class on the diagram, and that bringing up
the source code. This would however require an interactive tool of sorts, and
was outside the scope of this paper.
** Historical data extraction
By generating these graphs as code it can be easy to generate it for various
versions of the sourcecode, via version control, and with that generate an
evolutionary graph, essentially highlighting the difference between two graphs
and showing any additions and deletions. A small animation could show this
evolution, but also show changes that result from pull requests, for instance.
This could be usable as a crucial step in a code review phase, where a similar
graph could show the structural changes a given pull request creates, which is
as interesting, if not more, than the difference in code.
** Different graphs
Through other types of code analysis it would be interesting to see, if
possible, the generation of various scenarios and usage of the system. You could
also, through version control, highlight what areas of the code is most
contested and most frequently causes conflicts, for instance. The two graphs
shown here are relatively simple, and even more knowledge could be extracted
with more time and work.
** Monitoring based code analysis
One of the problems faced, when generating the class diagram, was the inability
to see exactly what types would be supplied to various functions - this resulted
in some dependencies lacking from the generated diagrams. An alternative
solution would be to analyze the call stacks and usage while running the system.
By logging the types of arguments one could come closer to a realistic
view. An additional benefit would be the ability to distinguish between a
close knitted association and dependency based on how often one class calls
another. This could also lead to discovery of ghost code, and various other
aspects. An obviously problem here would be the overhead created by such a
monitoring tool, however one could run it on unit tests, granted they represent
a realistic usage, or on a staging server of sorts.
** Proposing a concrete new structure for the =Flask= class
The paper briefly covered the large size of the =flask.app.Flask= class, and
breaking this into multiple classes, based on responsibilities, would be an
interesting next task. This is outside the scope of this paper due to the large
size of the paper, however based on quick glimpses into the class, one could
probably start by splitting it into these three new responsibilities;
=Runner=, =ErrorHandler=, =TemplateHandler=. However a concrete division should
only be agreed upon after closer inspection and analysis.

* Footnotes
[fn:flask] https://flask.palletsprojects.com/en/1.1.x/
[fn:minimal_app] https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application
[fn:repo] https://github.com/pallets/flask
[fn:wsgi] https://wsgi.readthedocs.io/en/latest/index.html
[fn:dirfunc] https://docs.python.org/3.8/library/functions.html#dir
[fn:reflection] https://wsgi.readthedocs.io/en/latest/index.html
[fn:graphviz] https://en.wikipedia.org/wiki/Graphviz
[fn:pip] https://pypi.org/project/Flask/
[fn:jinja] https://jinja.palletsprojects.com/en/2.11.x/
[fn:bigmudball] https://en.wikipedia.org/wiki/Big_ball_of_mud
[fn:api_docs] https://flask.palletsprojects.com/en/1.1.x/#api-reference
[fn:4plus1] http://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf
[fn:3plus1] An Approach to Software Architecture Description Using UML (Revision2.0)
[fn:chosen_issue] https://github.com/pallets/flask/issues/3396
[fn:symphony] Van Deursen et al. -- Symphony - View-Driven Architecture ReconstructionFile
[fn:report_source] https://github.com/C0DK/soft_arch_recovery
[fn:pep8] https://www.python.org/dev/peps/pep-0008/
